0000	8003	LDH R0,03 ; endereco de k1 em R0
0001	7052	LDL R0,52
0002	8104	LDH R1,04 ; endereco de identidade_A
0003	7107	LDL R1,07
0004	4222	XOR R2,R2,R2
0005	9020	LD R0, R2, R0 ; k1 e igual a matriz identidade_A
0006	A021	ST R0, R2, R1
0007	730F	LDL R3,0F
0008	4444	XOR R4,R4,R4
0009	8003	LDH R0,03 ; end base X[] (RAM)
000A	7054	LDL R0,54
000B	8104	LDH R1,04 ; end base B[] (MPU)
000C	7130	LDL R1,30
000D	9504	LOOP1:LD R5,R0,R4 ; LOOP que faz o store de X[] em B[]
000E	A514	ST R5,R1,R4
000F	5401	ADDI R4,01
0010	6301	SUBI R3,01
0011	E002	JMPND #PROX1
0012	7F0D	LDL R15,0D
0013	C0F5	JUMP R15 ; B[] <= X[]
0014	8104	PROX1:LDH R1,04 ; end mul (MPU)
0015	7105	LDL R1,05
0016	A221	ST R2,R2,R1 ; MPU recebe endereco para multiplicar A[] com B[] - C[] <= (k1 * C[])
0017	8003	LDH R0,03 ; end base X[] (RAM)
0018	7052	LDL R0,54
0019	8104	LDH R1,04 ; end base C[] (MPU)
001A	710F	LDL R1,0F
001B	4444	XOR R4,R4,R4
001C	4333	XOR R3,R3,R3
001D	730F	LDL R3,0F ; contador
001E	9614	LOOP2:LD R6,R1,R4 ; carrega X[] (RAM) com C[] (MPU)
001F	A604	ST R6,R0,R4
0020	5401	ADDI R4,01
0021	6301	SUBI R3,01
0022	E003	JMPND #PROX2
0023	4FFF	XOR R15,R15,R15
0024	7F1E	LDL R15,1E
0025	C0F5	JUMP R15 ; X[] <= k1 * X[]
0026	8003	PROX2:LDH R0,03 ; endereco de k2 em R0
0027	7053	LDL R0,53
0028	8104	LDH R1,04 ; endereco de identidade_A
0029	7107	LDL R1,07
002A	9620	LD R6, R2, R0 ; k2 e igual a matriz identidade_A
002B	A621	ST R6, R2, R1
002C	8003	LDH R0,03 ; end base Z[] (RAM)
002D	7074	LDL R0,74
002E	8104	LDH R1,04 ; end base B[] (MPU)
002F	7130	LDL R1,30
0030	4444	XOR R4,R4,R4
0031	4333	XOR R3,R3,R3
0032	730F	LDL R3,0F ; contador
0033	9604	LOOP3:LD R6,R0,R4 ; carrega B[] (MPU) com Z[] (RAM)
0034	A614	ST R6,R1,R4
0035	5401	ADDI R4,01
0036	6301	SUBI R3,01
0037	E003	JMPND #PROX3
0038	4FFF	XOR R15,R15,R15
0039	7F33	LDL R15,33
003A	C0F5	JUMP R15
003B	8104	PROX3:LDH R1,04 ; end mul (MPU)
003C	7105	LDL R1,05
003D	9F21	LD R15,R2,R1 ; MPU recebe endereco para multiplicar A[] com B[] - C[] <= k2 * Z[]
003E	8003	LDH R0,03 ; end base X[] (RAM)
003F	7054	LDL R0,54
0040	8104	LDH R1,04 ; end base A[] (MPU)
0041	711F	LDL R1,1F
0042	4444	XOR R4,R4,R4
0043    4333	XOR R3,R3,R3
0044	770F	LDL R7,0F ; contador
0045	9604	LOOP4:LD R6,R0,R4 ; LOOP que faz o store de X[] em A[]
0046	A614	ST R6,R1,R4
0047	5401	ADDI R4,01
0048	6701	SUBI R7,01
0049	E003	JMPND #PROX4
004A	4FFF	XOR R15,R15,R15
004B	7945	LDL R9,45
004C	C095	JUMP R9
004D	8003	PROX4: LDH R0,03 ; end base Y[] (RAM)
004E	7064	LDL R0,64
004F	8104	LDH R1,04 ; end base B[] (MPU)
0050	7130	LDL R1,30
0051	4444	XOR R4,R4,R4
0052	4333	XOR R3,R3,R3
0053	730F	LDL R3,0F ; contador
0054	9604	LOOP5:LD R6,R0,R4 ; carrega Y[] (RAM) em B[] (MPU)
0055	A614	ST R6,R1,R4
0056	5401	ADDI R4,01
0057	6301	SUBI R3,01
0058	E003	JMPND #PROX5
0059	4FFF	XOR R15,R15,R15
005A	7A54	LDL R10,54
005B	C0A5	JUMP R10
005C	8104	LDH R1,04 ; end mac (MPU)
005D	7106	LDL R1,06
005E	9F21	LD R15,R2,R1 ; MPU recebe endereco para multiplicar A[] ((k1 * X[]) x Y[]) com B[] (matriz identidade com 1) e somar C[] (k2 * Z[])
005F	8003	LDH R0,03 ; end base Z[] (RAM)
0060	7074	LDL R0,74
0061	8104	LDH R1,04 ; end base C[] (MPU)
0062	710F	LDL R1,0F
0063	4444	XOR R4,R4,R4
0064	4333	XOR R3,R3,R3
0065	730F	LDL R3,0F ; contador
0066	9514	LOOP6:LD R5,R1,R4 ; carrega Z[] (RAM) com C[] (MPU)
0067	A504	ST R5,R0,R4
0068	5401	ADDI R4,01
0069	6301	SUBI R3,01
006A	E003	JMPND #FIM
006B	4AAA	XOR R10,R10,R10
006C	7A66	LDL R10,66
006D	C0A5	JUMP R15 ; Z[] <= (((k1 * X[]) x Y[]) x 1) + (k2 * Z[])
006E	B006	FIM: HALF
0352	3650	k1 ; endereco 850
0353	485D	k2
0354	7CE7	X
0355	25E3
0356	0310
0357	1F56
0358	3A91
0359	366B
035A	4126
035B	314A
035C	4E50
035D	139B
035E	0096
035F	0D3E
0360	0DEB
0361	73A8
0362	380E
0363	4336
0364	2D20	Y
0365	4FF0
0366	7DC9
0367	4993
0368	5DA1
0369	14E7
036A	47B3
036B	4C9F
036C	305C
036D	0E55
036E	76CE
036F	1C67
0370	1BFF
0371	63BF
0372	31D4
0373	2CC9
0374	4CBC	Z
0375	3922
0376	531E
0377	5BCD
0378	214A
0379	47E8
037A	6DC4
037B	7239
037C	792C
037D	0414
037E	2E06
037F	125F
0380	3835
0381	21C0
0382	18EB
0383	093A